/********** tell emacs we use -*- c++ -*- style comments *******************
 $Revision: 1.8 $  $Author: trey $  $Date: 2007-04-22 22:42:12 $
   
 @file    LSPathAndReactExec.cc
 @brief   No brief

 Copyright (c) 2002-2006, Trey Smith. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License"); you may
 not use this file except in compliance with the License.  You may
 obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 implied.  See the License for the specific language governing
 permissions and limitations under the License.

 ***************************************************************************/

/***************************************************************************
 * INCLUDES
 ***************************************************************************/

//#include <assert.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <assert.h>
#include <sys/time.h>

#include <iostream>
#include <fstream>

#include "zmdpCommonDefs.h"
#include "MatrixUtils.h"
#include "LSPathAndReactExec.h"
#include "LifeSurvey.h"
#include "Pomdp.h"

using namespace std;
using namespace MatrixUtils;
using namespace sla;

#define LS_NUM_PATHS_TO_EVALUATE (1000000)
#define LS_ABS(x) (((x) < 0) ? -(x) : (x))

namespace zmdp {

LSPathAndReactExec::LSPathAndReactExec(void)
{}

// read in the pomdp model and the policy generated by 'zmdp solve'
void LSPathAndReactExec::init(const std::string& lifeSurveyFileName,
			      const ZMDPConfig* config)
{
  useBlindActionSelection = (config->getString("policyType") == "lsblind");
  if (useBlindActionSelection) return;

  timeval tv1, tv2;
  printf("LSPathAndReactExec: reading LifeSurvey model\n");
  gettimeofday(&tv1, NULL);
  m.init(lifeSurveyFileName);
  gettimeofday(&tv2, NULL);
  printf("  (took %.3f seconds)\n",
	 (tv2.tv_sec - tv1.tv_sec) + 1e-6*(tv2.tv_usec - tv1.tv_usec));
    
  generatePath();
}

void LSPathAndReactExec::setToInitialState(void)
{
  if (useBlindActionSelection) return;

  std::vector<LSOutcome> initStates;
  m.getInitialStateDistribution(initStates);

  // (reduce state distribution to a deterministic state)
  assert(initStates.size() > 0);
  currentLSState = initStates[0].nextState;
  FOR (i, 3) {
    // assume no life unless life is positively sensed
    currentLSState.lifeInNeighborCell[i] = 0;
  }
}

/*
   selects action according to the following heuristics:
   1. if the lookahead action has not yet been used in this cell,
      use it.
   2. otherwise:
      a. if any of the forward cells is *both* in an unsampled region
         *and* had a positive lookahead reading, the action will be a sampling move.
         otherwise the action will be a non-sampling move.
      b. the move direction is chosen according to the following
         heuristics (in decreasing order of importance):
         i.   prefer cells that *both* had a positive lookahead reading
              and are in an unsampled region.
         ii.  prefer cells that are closer to the pre-selected path.
         iii. prefer move direction of NE > SE > E.
*/
int LSPathAndReactExec::chooseAction(void)
{
  if (useBlindActionSelection) {
    return 4;
  }

  LSAction a;
  const LSModelFile& f = m.mfile;

  if (currentLSState.usedLookaheadInThisCell) {
    a.type = LS_ACT_MOVE;

    double val;
    bool targetExists = false;
    double bestVal = -99e+20;
    int bestDir = -1;
    FOR (dir, 3) {
      // check if a move in the given direction is legal
      LSPos nextPos = m.getNeighbor(currentLSState.pos, dir);
      unsigned char r = f.grid.getCellBounded(nextPos);
      if (LS_OBSTACLE == r
	  || (LS_NE == currentLSState.lastMoveDirection && LS_SE == dir)
	  || (LS_SE == currentLSState.lastMoveDirection && LS_NE == dir)) {
	continue;
      }

      // evaluate the move according to heuristic criteria
      val = 0;
      if (currentLSState.rewardLevelInRegion[r] < 3
	  && currentLSState.lifeInNeighborCell[dir]) {
	val += 10000;
	targetExists = true;
      }
      val -= 100 * getDistanceToNearestPathCell(nextPos);
      val += (LS_NE == dir) ? 2 : ((LS_SE == dir) ? 1 : 0);
      
      if (val > bestVal) {
	bestVal = val;
	bestDir = dir;
      }
    }

    if (-1 == bestDir) {
      fprintf(stderr, "ERROR: LSPathAndReactExec::chooseAction: in pos (%d,%d) -- there are no legal moves!\n",
	      currentLSState.pos.x, currentLSState.pos.y);
      exit(EXIT_FAILURE);
    }

    // move in the best direction
    a.useSample = targetExists;
    a.moveDirection = bestDir;
  } else {
    // lookahead not already used
    a.type = LS_ACT_LOOK;
  }

#if 0
  printf("chooseAction: s=%s a=%s\n",
	 currentLSState.toString().c_str(),
	 a.toString().c_str());
#endif

  return a.toInt();
}

void LSPathAndReactExec::advanceToNextState(int ai, int oi)
{
  LSObservation o(oi);
#if 0
  LSAction a(ai);
  printf("advanceToNextState: a=%s o=%s\n",
	 a.toString().c_str(),
	 o.toString().c_str());
#endif

  // get possible next outcomes according to probabilistic LS model
  std::vector<LSOutcome> outcomes;
  double reward;
  m.getOutcomes(outcomes, reward, currentLSState, ai);

  // reduce distribution to deterministic next state
  LSState nextLSState = outcomes[0].nextState;

  // muck with lifeInNeighborCell to follow the right deterministic logic
  if (o.isNull) {
    // last action was a move; we believe none of the cells in front has life
    // until we get a positive lookahead observation
    FOR (i, 3) {
      nextLSState.lifeInNeighborCell[i] = 0;
    }
  } else {
    // last action was a lookahead; mark high confidence neighbor cells
    // as containing life
    FOR (i, 3) {
      if (LS_BASE_NUM_OBSERVATIONS-1 == o.lifeInNeighborConfidence[i]) {
	nextLSState.lifeInNeighborCell[i] = 1;
      }
    }
  }

  currentLSState = nextLSState;
}

int LSPathAndReactExec::getDistanceToNearestPathCell(const LSPos& pos) const
{
  int minDist = 9999;
  FOR_EACH (cellP, plannedPath) {
    const LSPos& cell = cellP->pos;
    int dx = pos.x - cell.x;
    int dy = pos.y - cell.y;
    int dist;
    if (dx*dy < 0) {
      dist = LS_ABS(dx) + LS_ABS(dy);
    } else {
      dist = std::max(LS_ABS(dx), LS_ABS(dy));
    }

    minDist = std::min(minDist, dist);
  }
  return minDist;
}

/*
  sets plannerPath to be the path that has the largest expected number of
  distinct regions r such that life is sampled in r.
*/
void LSPathAndReactExec::generatePath(void)
{
  printf("LSPathAndReactExec: generating path\n");
  const LSModelFile& f = m.mfile;

  LSPathEntry entry;
  entry.pos = LSPos(f.startX, f.startY);
  entry.lastMoveDirection = LS_E;

  LSPath initialPrefix;
  initialPrefix.push_back(entry);

  bestValueMap.clear();
  bestValueMap.resize(f.grid.width*f.grid.height*3);
  numPathsEvaluated = 0;

  double plannedPathValue;
  LSValueEntry initialValue;
  initialValue.unreachableRegionValue = 0;
  initialValue.regionCounts.resize(m.mfile.regionPriors.size(), 0);

  getBestExtension(plannedPath, plannedPathValue, initialPrefix,
		   initialValue);

#if 1
  // debug
  printf("  numPathsEvaluated=%d\n", numPathsEvaluated);
  printf("  best path value (expected number of life samples): %lf\n",
	 plannedPathValue);
  printf("  best path:\n");
  int j=0;
  printf("    ");
  FOR_EACH (cellP, plannedPath) {
    printf("(%2d,%2d) ", cellP->pos.x, cellP->pos.y);
    if (0 == (++j % 5)) {
      printf("\n    ");
    }
  }
  printf("\n");
#endif
}

void LSPathAndReactExec::getBestExtension(LSPath& bestPathMatchingPrefix,
					  double& bestPathValue,
					  LSPath& prefix,
					  const LSValueEntry& valueSoFar)
{
  const LSModelFile& f = m.mfile;
  LSPathEntry entry = prefix.back();

  // set up default return value
  bestPathMatchingPrefix = LSPath();
  bestPathValue = -999;

  // add forward neighbors of current cell to regionCounts
  LSValueEntry nextValueSoFar = valueSoFar;
  FOR (dir, 3) {
    LSPos nextPos = m.getNeighbor(entry.pos, dir);
    int nextCellRegion = f.grid.getCellBounded(nextPos);
    if (LS_OBSTACLE == nextCellRegion
	|| (LS_SE == entry.lastMoveDirection && LS_NE == dir)
	|| (LS_NE == entry.lastMoveDirection && LS_SE == dir)) {
      // invalid move
    } else {
      nextValueSoFar.regionCounts[nextCellRegion]++;
    }
  }

  // fold counts of unreachable regions into unreachableRegionValue
  // (all regions are considered unreachable if we are at the exit)
  bool atExit = f.grid.getAtExit(entry.pos);
  FOR (r, f.regionPriors.size()) {
    if (LS_UNREACHABLE != nextValueSoFar.regionCounts[r]) {
      if (atExit || !m.regionReachable[r].getCell(entry.pos)) {
	double probLifeIsSampledInRegion =
	  1 - pow(1 - f.regionPriors[r],
		  nextValueSoFar.regionCounts[r]);
	nextValueSoFar.unreachableRegionValue += probLifeIsSampledInRegion;
	nextValueSoFar.regionCounts[r] = LS_UNREACHABLE;
      }
    }
  }

  // debug
  numPathsEvaluated++;
  if (prefix.size() > 5) {
    if (0 == (numPathsEvaluated % 100000)) {
      printf("... %d%d%d%d\n",
	     prefix[1].lastMoveDirection,
	     prefix[2].lastMoveDirection,
	     prefix[3].lastMoveDirection,
	     prefix[4].lastMoveDirection);
    }
  }

  if (getValueIsDominated(entry, nextValueSoFar)) {
    // there is another path going through this cell that is
    // at least as good as this one; prune this search branch
    return;
  }

  if (atExit) {
    // prefix is a complete path through the map; return it

    bestPathMatchingPrefix = prefix;
    bestPathValue = nextValueSoFar.unreachableRegionValue;

  } else {
    // prefix is a partial path through the map; choose the best extension

    // try out different extensions of prefix and keep the best
    LSPathEntry nextEntry;
    LSPath extension;
    FOR (dir, 3) {
      nextEntry.pos = m.getNeighbor(entry.pos, dir);
      nextEntry.lastMoveDirection = dir;
      int nextCellRegion = f.grid.getCellBounded(nextEntry.pos);
      if (LS_OBSTACLE == nextCellRegion
	  || (LS_SE == entry.lastMoveDirection && LS_NE == dir)
	  || (LS_NE == entry.lastMoveDirection && LS_SE == dir)) {
	// invalid move
      } else {
	// calculate the best extension that includes moving in direction <dir>
	double extVal;
	prefix.push_back(nextEntry);
	getBestExtension(extension, extVal, prefix, nextValueSoFar);
	prefix.pop_back();

	if (extVal > bestPathValue) {
	  bestPathMatchingPrefix = extension;
	  bestPathValue = extVal;
	}
      }
    }
  }
}

bool LSPathAndReactExec::getValueIsDominated(const LSPathEntry& pe,
					     const LSValueEntry& val)
{
  const LSModelFile& f = m.mfile;
  LSValueVector& vec = bestValueMap[3*(f.grid.width*pe.pos.y + pe.pos.x)
				    + pe.lastMoveDirection];
  FOR_EACH (entryP, vec) {
    if (dominates(*entryP, val)) return true;
  }

  // val is not dominated by any existing entry in vec; add
  // val to vec
  vec.push_back(val);
  return false;
}

bool LSPathAndReactExec::dominates(const LSValueEntry& val1,
				   const LSValueEntry& val2)
{
  if (val1.unreachableRegionValue < val2.unreachableRegionValue) {
    return false;
  }
  assert(val1.regionCounts.size() == val2.regionCounts.size());
  FOR (i, val1.regionCounts.size()) {
    if (val1.regionCounts[i] < val2.regionCounts[i]) return false;
  }
  return true;
}

}; // namespace zmdp

/***************************************************************************
 * REVISION HISTORY:
 * $Log: not supported by cvs2svn $
 * Revision 1.7  2007/03/23 00:01:20  trey
 * fixed to reflect migration from PomdpExec to MDPExec base class
 *
 * Revision 1.6  2006/11/08 16:42:38  trey
 * changed Pomdp constructor arguments
 *
 * Revision 1.5  2006/07/06 16:15:44  trey
 * added sanity check in advanceToNextBelief() to catch impossible observations
 *
 * Revision 1.4  2006/07/03 14:30:06  trey
 * code no longer makes subtly invalid assumptions about when one path dominates another, so the output path is guaranteed to be optimal (luckily, seems to output the same path as before)
 *
 * Revision 1.3  2006/06/30 17:50:37  trey
 * fixed core dump from shadowing variable declaration
 *
 * Revision 1.2  2006/06/29 21:59:38  trey
 * weird bug in generated path seems to be fixed; chooseAction() still broken
 *
 * Revision 1.1  2006/06/29 21:37:56  trey
 * initial check-in
 *
 *
 ***************************************************************************/
